{
  "hash": "27facda34b9ab360bf875ad8add5a1e0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 6\"\ndate: '12/7/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: \"https://miro.medium.com/max/1400/1*8NspdbQcI6w6tjZQ7kjS-A.png\"\n---\n\n\n![](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*8NspdbQcI6w6tjZQ7kjS-A.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\nWhat is going on with these puzzles?! Difficulty dropped quite a bit again for the even day puzzles.\n\n# Part 1\n\nLet's recap on the puzzle prompt.\n\n> Determine the number of ways you could beat the record in each race. What do you get if you multiply these numbers together?\n\nLet's first start off with reading in the puzzle input and tidy the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(\n  here('posts', 'aoc-2023-d6', 'puzzle-input.txt')\n)\n\ndata <- data |>\n  as_tibble() |>\n  separate(value, c('type', 'value'), sep = ': ') |>\n  mutate(\n    value = str_trim(value),\n    value = str_split(value, ' '),\n    value = map(value, \\(x) as.numeric(x) |> na.omit())\n  ) |>\n  unnest(value) |>\n  mutate(race = rep(1:4, 2)) |>\n  pivot_wider(names_from = type, values_from = value)\n\ndata <- data |> janitor::clean_names()\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n   race  time distance\n  <int> <dbl>    <dbl>\n1     1    53      333\n2     2    83     1635\n3     3    72     1289\n4     4    88     1532\n```\n\n\n:::\n:::\n\n\nThe idea of this puzzle is that we have 4 toy boat races that we need to figure out the number of ways that we can beat the record for the boat races. For each toy boat, we can hold the button down to make the boat go faster. The speed is directly correlated with the amount of time the button is held e.g. 1 milisecond = 1 milimeter/milisecond, 2 milisecond = 2 milimeter/milisecond, etc. However for each milisecond we hold the button down, the time will go against the amount of time alotted to travel the distance. If we hold the button down for too long, then we won't have time to travel. If we hold the button down for too short, then the boat won't have any speed to travel the necessary distance to beat the record.\n\nLet's create a function that allows us to tabulate the button hold, dependent on the total time and the amount of time the button was held.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalculate_total_distance <- \\(total_time, button_hold) {\n  speed <- button_hold\n  \n  time_remaining <- total_time - button_hold\n  total_distance <- speed * time_remaining\n  \n  total_distance\n  \n}\n```\n:::\n\n\nLet's create a tibble with all possible amount of time  to hold the button from 0 milisecond to the total time for each race. Now let's tabulate the total distance traveled for all possible time the button was held. Finally let's identify the rows, where the total distance traveled from our toy boat exceeeded the distance traveled for the record. We can then count the total rows for each record, and determine the product for the answer.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- pmap(data, \\(race, time, distance) {\n  temp <- tibble(total_time = time,\n                 button_hold = 0:time,\n                 distance)\n  \n  temp |>\n    mutate(total_distance = calculate_total_distance(total_time, button_hold)) |> \n    filter(total_distance > distance) |> \n    nrow()\n  \n})\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 38\n\n[[2]]\n[1] 18\n\n[[3]]\n[1] 5\n\n[[4]]\n[1] 41\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres |> unlist() |> prod()\n```\n:::\n\n\nfirst attempt: 140220\n\n# Part 2\n\n> How many ways can you beat the record in this one much longer race?\n\nThe strategy for part 2 is identical for part 1, however now we have 1 single race instead of 4 races. We then calculate the total number of ways we can beat the record in this much longe race\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(here('posts', 'aoc-2023-d6', 'puzzle-input.txt'))\n\ndata <- data |>\n  as_tibble() |>\n  separate(value, c('type', 'value'), sep = ': ') |>\n  mutate(\n    value = str_trim(value, side = 'both'),\n    value = str_remove_all(value, ' '),\n    value = as.numeric(value)\n  ) |>\n  pivot_wider(names_from = type, values_from = value) |>\n  janitor::clean_names()\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n      time distance\n     <dbl>    <dbl>\n1 53837288  3.33e14\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- tibble(\n  total_time = data$time,\n  button_hold = 0:data$time,\n  distance = data$distance\n)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 53,837,289 × 3\n   total_time button_hold distance\n        <dbl>       <int>    <dbl>\n 1   53837288           0  3.33e14\n 2   53837288           1  3.33e14\n 3   53837288           2  3.33e14\n 4   53837288           3  3.33e14\n 5   53837288           4  3.33e14\n 6   53837288           5  3.33e14\n 7   53837288           6  3.33e14\n 8   53837288           7  3.33e14\n 9   53837288           8  3.33e14\n10   53837288           9  3.33e14\n# ℹ 53,837,279 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres |>\n  mutate(total_distance = calculate_total_distance(total_time, button_hold)) |>\n  filter(total_distance > distance) |> \n  nrow()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}