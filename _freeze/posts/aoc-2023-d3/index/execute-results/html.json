{
  "hash": "7a92ab88d7d684a8389361b7bae1af10",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 3\"\ndate: '12/4/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: \"https://miro.medium.com/max/1400/1*8NspdbQcI6w6tjZQ7kjS-A.png\"\n---\n\n\n![](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*8NspdbQcI6w6tjZQ7kjS-A.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\nWow what a doozie, the increase in difficulty was significant compared to Day 2. This was a fun one though, I think I could have done it in a more efficient way, but I was happy with the solution I came up with.\n\n# Part 1\n\nLet's start off with the prompt for this puzzle\n\n> What is the sum of all of the part numbers in the engine schematic?\n\nWe start off with reading in and preparing the data. I replaced all of the `.` with spaces so that I could use a more simple regex to identify the symbols later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(here('posts', 'aoc-2023-d3', 'puzzle-input.txt'))\n\ndata <- as_tibble(data)\n\ndata <- data |>\n  mutate(row = row_number(),\n         .before = value) |>\n  mutate(value = str_replace_all(value, '\\\\.', ' '))\n```\n:::\n\n\nHere are some observations I made regarding the symbols and the values.\n\nrow 2, column 28 is a symbol\n\n- row 1, column 27 is a valid spot (above and left of the symbol)\n- row 1, column 28 is a valid spot (above the symbol)\n- row 1, column 29 is a valid spot (above and right of the symbol)\n- row 2, column 27 is a valid spot (left of the symbol)\n- row 2, column 28 is location of the symbol\n- row 2, column 29 is a valid spot (right of the symbol)\n- row 3, column 27 is a valid spot (below and left of the symbol)\n- row 3, column 28 is a valid spot (below the symbol)\n- row 3, column 29 is a valid spot (below and right of the symbol)\n\nThe main observations is that the symbol is always in the center of a 3 by 3 grid. We can use this to identify the locations of the symbols. We need to identify all of the adjacent cells that are valid, and then we can use this to identify the locations of the valid parts numbers. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 140 × 2\n     row value                                                                  \n   <int> <chr>                                                                  \n 1     1 \"                       153  988    502  842         588     441 468  …\n 2     2 \"            805            *      #             %               *    …\n 3     3 \"        914         #   617  201         271     671      52  898    …\n 4     4 \"          #      361          *           *            -4            …\n 5     5 \"490*                          350   *   664        806               …\n 6     6 \"    245               805           467       449   +              31…\n 7     7 \"                        *     150             *              8       …\n 8     8 \"435                 688 8              $      330                 474…\n 9     9 \"   * *    920        %                666  90     786$  221       *  …\n10    10 \" 718 120  @             $ 931                *           *    15   10…\n# ℹ 130 more rows\n```\n\n\n:::\n:::\n\n\nWe write two helper functions to identify the locations of the symbols and the part numbers. We use the `[:symbol:]` and `[:punct:]` character classes to identify the symbols, and the `[:digit:]` character class to identify the part numbers. For the symbols location, I also tabulated the 'start', and 'end' of the locations adjacent to the symbol in the helper function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nidentify_symbols_location <- \\(x) {\n  str_locate_all(x, '[:symbol:]|[:punct:]')[[1]] |>\n    as_tibble() |> \n    select(symbol = start) |> \n    mutate(\n      symbol_start = symbol - 1,\n      symbol_end = symbol + 1\n    )\n}\n\nidentify_parts_location <- \\(x) {\n  \n  str_locate_all(x, '[:digit:]+')[[1]] |> \n    as_tibble() |> \n    rename(\n      'parts_start' = start,\n      'parts_end' = end\n    )\n  \n}\n\ndata <- data |>\n  mutate(\n    symbol_locations = map(value, \\(value) identify_symbols_location(value)),\n    part_number_locations = map(value, identify_parts_location),\n    part_number_locations = map2(value, part_number_locations, \\(value, part_number_locations) {\n      part_number_locations |>\n        mutate(part_number = str_sub(value, parts_start, parts_end),\n               .before = parts_start)\n    })\n  )\n```\n:::\n\n\nI next construct a tibble of the grid that we are working with. This is a 140 by 140 grid, and we will use this as a template to merge the locations of the symbols, parts number, and the values into.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- crossing(\n  row = 1:140,\n  column = 1:140\n)\n```\n:::\n\n\nOnce we get the symbol locations we merge this back into our grid. The trick to this part is to identify the adjacent cells to the symbol, and then merge this back into the grid. I did this by first unnesting the symbol locations, and then I created a list of the adjacent cells to the symbol. I then unnested this list, and then merged this back into the grid. I then filled in the symbol column with a 1 if the cell was a symbol, and a 0 if it was not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsymbol_locations <- data |>\n  select(row, symbol_locations) |>\n  unnest(symbol_locations) |>\n  rowwise() |>\n  mutate(row = list(row + c(-1, 0, 1))) |>\n  unnest(row) |>\n  rowwise() |>\n  mutate(column = list(symbol_start:symbol_end)) |>\n  unnest(column) |>\n  select(row, column) |> \n  mutate(symbol = 1)\n\ngrid <- grid |> \n  left_join(symbol_locations, by = join_by(row, column)) |> \n  mutate(symbol = ifelse(is.na(symbol), 0, symbol))\n```\n:::\n\n\nNext I wanted to extract out the values from the puzzle input. I split the values into individual characters, and then I merged this back into the grid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalues <- data |> \n  select(row, value) |> \n  mutate(value = str_split(value, '')) |> \n  unnest(value) |> \n  group_by(row) |>\n  mutate(column = row_number()) |> \n  ungroup()\n\ngrid <- grid |> \n  left_join(values, by = join_by(row, column))\n```\n:::\n\n\nNext I extracted out the location of the parts numbers, then again merged this back into the grid. I further checked to see if the parts numbers are 'valid' or adjacent to a symbol. I did this by checking whether the parts number falls on any of the symbol adjacent cells `symbol = 1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparts_number <- data |>\n  select(row, part_number_locations) |>\n  unnest(part_number_locations) |>\n  mutate(i = row_number()) |> \n  rowwise() |>\n  mutate(column = list(parts_start:parts_end)) |> \n  unnest(column) |> \n  select(i, row, column, part_number)\n\ngrid <- grid |> \n  left_join(parts_number, by = join_by(row, column)) |> \n  group_by(row, part_number) |>\n  mutate(\n    valid = ifelse(any(symbol == 1), TRUE, FALSE),\n    valid = ifelse(is.na(part_number), FALSE, valid)\n  ) |> \n  ungroup()\n```\n:::\n\n\nNow that we have all the locations of the symbols, parts numbers, and the values, we can plot the grid. We can see that the symbols are in the center of a 3 by 3 grid (grey). We can also see that any part numbers that fall within the 3 by 3 grid are valid (red).\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nggplot(grid, aes(x = column, y = row, fill = factor(symbol))) + \n  geom_tile() + \n  coord_equal() +\n  scale_y_reverse() +\n  geom_text(aes(label = value, color = valid), size = 2) +\n  theme_void() + \n  scale_color_manual(values = c('black', 'red')) +\n  scale_fill_manual(values = c('white', 'grey90')) +\n  theme(\n    legend.position = 'none'\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=100%}\n:::\n:::\n\n\nNow that we have all of the data in a tidy dataframe, we can identify the valid parts numbers, and take the sum of the parts numbers to get the answer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid |> \n  filter(!is.na(part_number)) |>\n  filter(valid == TRUE) |> \n  select(i, row, part_number) |>\n  distinct() |>\n  summarize(part_number = sum(as.numeric(part_number)))\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}