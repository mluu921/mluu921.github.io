{
  "hash": "e38dc6fe5c2a6ba105398e3d3637d6aa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 15\"\ndate: '12/24/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: \"https://miro.medium.com/max/1400/1*8NspdbQcI6w6tjZQ7kjS-A.png\"\n---\n\n\n\n\n![](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*8NspdbQcI6w6tjZQ7kjS-A.png)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(rlang)\n```\n:::\n\n\n\n\n# Part 1\n\nAnother fairly straight forwad puzzle. We are given an algorithm that we need to follow. The algorithm is as follows:\n\n- Determine the ASCII code for the current character of the string.\n- Increase the current value by the ASCII code you just determined.\n- Set the current value to itself multiplied by 17.\n- Set the current value to the remainder of dividing itself by 256.\n\nAs always let's read in the puzzle input and tidy the input into something we can work with.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(\n  here('posts', 'aoc-2023-d15', 'puzzle-input.txt')\n)\n\ndata <- data |> \n  str_split(',') |> \n  unlist() |> \n  as_tibble()\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 × 1\n   value   \n   <chr>   \n 1 fzl-    \n 2 tcjp=8  \n 3 vkjr=9  \n 4 xs-     \n 5 jktcpk=3\n 6 gzp-    \n 7 kfsxsd- \n 8 zxkv=7  \n 9 fxz-    \n10 pj=7    \n# ℹ 3,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nNow let's write a helper function that can help us decode the hash based on the provided algorithm.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhash_decoder <- \\(hash) {\n  \n  hash <- hash |> str_split('') |> unlist()\n  \n  current_value <- 0\n  walk(hash, \\(x) {\n    ascii_code <- utf8ToInt(x)\n    current_value <- (current_value + ascii_code) * 17\n    current_value <<- current_value %% 256\n    \n  })\n  \n  return(current_value)\n  \n}\n```\n:::\n\n\n\n\nFinally let's apply the function across all of the values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data |> \n  rowwise() |> \n  mutate(\n    hash = hash_decoder(value)\n  ) |> \n  ungroup()\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 × 2\n   value     hash\n   <chr>    <dbl>\n 1 fzl-        41\n 2 tcjp=8      54\n 3 vkjr=9     243\n 4 xs-        200\n 5 jktcpk=3    23\n 6 gzp-       238\n 7 kfsxsd-    160\n 8 zxkv=7     119\n 9 fxz-       149\n10 pj=7        62\n# ℹ 3,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe solution of the puzzle is simply the sum of all the hash values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(data$hash)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}