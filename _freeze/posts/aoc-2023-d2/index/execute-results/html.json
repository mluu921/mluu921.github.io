{
  "hash": "0a9a5e65907914a770d694f87883e0f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 2\"\ndate: '12/3/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: 'https://camo.githubusercontent.com/45e775d95451f2bda211ee757d1a959671cf4c762feb1e7ccaca59925704e333/68747470733a2f2f626c6f67732e7361702e636f6d2f77702d636f6e74656e742f75706c6f6164732f323032302f31312f456b616f5151545845414d4134424e2e6a7067'\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\n# Part 1\n\nThe solution for Part 1 was actually quite simple. The major complexity of this puzzle is due to the data not being in a 'tidy' format. The majority of the code below is just cleaning the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(\n  here('posts', 'aoc-2023-d2', 'puzzle-input.txt')\n)\n\ndata <- as_tibble(data)\n\ndata <- data |> \n  separate(value, sep = ': ', into = c('game', 'value')) |> \n  separate(value, sep = '; ', into = paste0('set', 1:10)) |> \n  pivot_longer(contains('set'), names_to = 'set') |> \n  filter(!is.na(value)) |> \n  separate(value, sep = ', ', into = paste0('cube', 1:3)) |> \n  pivot_longer(contains('cube'), names_to = 'cube') |> \n  filter(!is.na(value)) |> \n  separate(value, sep = ' ', into = c('count', 'color')) |> \n  pivot_wider(names_from = 'color', values_from = 'count', values_fill = '0') |> \n  mutate(across(c('blue', 'red', 'green'), as.numeric)) |> \n  mutate(game_id = str_extract(game, '\\\\d+'), .after = game)\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,161 × 7\n   game   game_id set   cube   blue   red green\n   <chr>  <chr>   <chr> <chr> <dbl> <dbl> <dbl>\n 1 Game 1 1       set1  cube1     1     0     0\n 2 Game 1 1       set1  cube2     0     1     0\n 3 Game 1 1       set2  cube1     0    10     0\n 4 Game 1 1       set3  cube1     0     8     0\n 5 Game 1 1       set3  cube2     1     0     0\n 6 Game 1 1       set3  cube3     0     0     1\n 7 Game 1 1       set4  cube1     0     0     1\n 8 Game 1 1       set4  cube2     5     0     0\n 9 Game 2 2       set1  cube1     0     0     9\n10 Game 2 2       set1  cube2     0    11     0\n# ℹ 1,151 more rows\n```\n\n\n:::\n:::\n\n\nNow that we have the data in a 'tidy' format, let's refer back to the puzzle prompt.\n\n> The Elf would first like to know which games would have been possible if the bag contained only 12 red cubes, 13 green cubes, and 14 blue cubes?\n\nWe can figure this out by using `filter` on each color columns and checking whether any of the games contained any invalid number of cubes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- data |> \n  group_by(game) |>\n  mutate(\n    valid = case_when(\n      any(red > 12 | green > 13 | blue > 14) ~ FALSE,\n      .default = TRUE\n    )\n  ) |> \n  ungroup() |> \n  filter(valid == TRUE)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 539 × 8\n   game   game_id set   cube   blue   red green valid\n   <chr>  <chr>   <chr> <chr> <dbl> <dbl> <dbl> <lgl>\n 1 Game 1 1       set1  cube1     1     0     0 TRUE \n 2 Game 1 1       set1  cube2     0     1     0 TRUE \n 3 Game 1 1       set2  cube1     0    10     0 TRUE \n 4 Game 1 1       set3  cube1     0     8     0 TRUE \n 5 Game 1 1       set3  cube2     1     0     0 TRUE \n 6 Game 1 1       set3  cube3     0     0     1 TRUE \n 7 Game 1 1       set4  cube1     0     0     1 TRUE \n 8 Game 1 1       set4  cube2     5     0     0 TRUE \n 9 Game 2 2       set1  cube1     0     0     9 TRUE \n10 Game 2 2       set1  cube2     0    11     0 TRUE \n# ℹ 529 more rows\n```\n\n\n:::\n:::\n\n\nOnce we have the valid games, we can simply sum the game_id columns to get the solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres |> pull(game_id) |> unique() |> \n  as.numeric() |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2439\n```\n\n\n:::\n:::\n\n\n# Part 2\n\nAgain, the solution for Part 2 is quite simple once we have the data in a 'tidy' format. The elfs would like to know what is the 'minimum' number of cubes that has to be in each bag for each of the games played. The solution is the sum of the 'power' (defined as the product of the number of cubes for each color).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- data |> \n  group_by(game) |>\n  summarise(across(c(blue, red, green), \\(x) max(x))) |> \n  mutate(power = blue * red * green)\n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 5\n   game      blue   red green power\n   <chr>    <dbl> <dbl> <dbl> <dbl>\n 1 Game 1       5    10     1    50\n 2 Game 10      8     9    12   864\n 3 Game 100     5     7     1    35\n 4 Game 11      1    15     3    45\n 5 Game 12      8     9     7   504\n 6 Game 13      8     2    18   288\n 7 Game 14      4     3     5    60\n 8 Game 15     15     3     7   315\n 9 Game 16     20     6    13  1560\n10 Game 17     11     4     1    44\n# ℹ 90 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nres |> summarise(total_power = sum(power))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  total_power\n        <dbl>\n1       63711\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}