{
  "hash": "4f2bf76bbaf56bf9ac54977c23a0a766",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 9\"\ndate: '12/10/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: \"https://miro.medium.com/max/1400/1*8NspdbQcI6w6tjZQ7kjS-A.png\"\n---\n\n\n![](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*8NspdbQcI6w6tjZQ7kjS-A.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\n# Part 1\n\nPart 1 of this puzzle is fairly straight forward. The goal of Part 1 is to identify the next number in the 'history'. In order to identify the next value in the history, we need to identify the difference between the values, until the differences in the values is 0. We would then sum the last value of all the differences in order to obtain the next value in the history.\n\nThe puzzle prompt is as follows: \n\n> Analyze your OASIS report and extrapolate the next value for each history. What is the sum of these extrapolated values?\n\nWe would then take the sum of the predicted next history among all of the histories.\n\nLet's start off with reading in the puzzle input.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(\n  here('posts', 'aoc-2023-d9', 'puzzle-input.txt')\n)\n\ndata |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"12 12 11 5 -5 -5 40 194 558 1278 2553 4643 7877 12661 19486 28936 41696 58560 80439 108369 143519\"                  \n[2] \"6 12 33 79 163 320 638 1301 2644 5220 9879 17859 30889 51304 82172 127433 192050 282172 405309 570519 788607\"       \n[3] \"3 5 5 3 9 60 262 872 2445 6091 13915 29744 60271 116756 217404 390473 678031 1140057 1858241 2938353 4509389\"       \n[4] \"15 21 23 31 67 161 350 681 1224 2114 3674 6758 13659 30354 71646 172084 407585 935627 2065861 4378033 8910071\"      \n[5] \"13 32 75 155 286 477 724 1011 1347 1894 3301 7501 19549 51737 132449 324337 759840 1707391 3689542 7685418 15464987\"\n[6] \"9 23 59 129 245 419 663 989 1409 1935 2579 3353 4269 5339 6575 7989 9593 11399 13419 15665 18149\"                   \n```\n\n\n:::\n:::\n\n\nNow let's clean up the data a bit, we'll start by splitting the history by spaces and converting the history into a column of a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- map(data, \\(x) {\n  x |>\n    str_split(' ')  |>\n    unlist() |>\n    as_tibble() |>\n    mutate(value = as.numeric(value)) |>\n    rename('c0' = value)\n  \n})\n\ndata |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1    12\n 2    12\n 3    11\n 4     5\n 5    -5\n 6    -5\n 7    40\n 8   194\n 9   558\n10  1278\n# ℹ 11 more rows\n\n[[2]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1     6\n 2    12\n 3    33\n 4    79\n 5   163\n 6   320\n 7   638\n 8  1301\n 9  2644\n10  5220\n# ℹ 11 more rows\n\n[[3]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1     3\n 2     5\n 3     5\n 4     3\n 5     9\n 6    60\n 7   262\n 8   872\n 9  2445\n10  6091\n# ℹ 11 more rows\n\n[[4]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1    15\n 2    21\n 3    23\n 4    31\n 5    67\n 6   161\n 7   350\n 8   681\n 9  1224\n10  2114\n# ℹ 11 more rows\n\n[[5]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1    13\n 2    32\n 3    75\n 4   155\n 5   286\n 6   477\n 7   724\n 8  1011\n 9  1347\n10  1894\n# ℹ 11 more rows\n\n[[6]]\n# A tibble: 21 × 1\n      c0\n   <dbl>\n 1     9\n 2    23\n 3    59\n 4   129\n 5   245\n 6   419\n 7   663\n 8   989\n 9  1409\n10  1935\n# ℹ 11 more rows\n```\n\n\n:::\n:::\n\n\nI'm going to create two helper functions to facilitate this puzzle, first it's `generate_new_columns`. This function will create new columns with the differences based on the previous column. The second function `predicted_next_history` will continue to calculate the differences in new columns until all the values are zero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_new_columns <- \\(data, new_column, prev_column) {\n  prev_column <- rlang::parse_expr(prev_column)\n  new_column <- rlang::parse_expr(new_column)\n  \n  temp <- data |>\n    mutate(!!new_column := !!prev_column - lag(!!prev_column)) |>\n    select(!!new_column)\n  \n  bind_cols(data, temp)\n  \n}\n\npredicted_next_history <- \\(history) {\n\n  all_zeroes <- FALSE\n  i <- 0\n  temp <- history\n  prev <- NULL\n  \n  while (all_zeroes == FALSE) {\n    new <- paste0('c', i + 1)\n    prev <- paste0('c', i)\n    \n    temp <- generate_new_columns(temp, new, prev)\n    new_column <- temp |> pull(!!new) |> na.omit()\n    all_zeroes <- all(new_column == 0)\n    \n    i <- i + 1\n    \n  }\n  \n  values <- map(temp, \\(x) {\n    vals <- x |> na.omit()\n    \n    total_vals <- length(vals)\n    \n    return(vals[total_vals])\n    \n  })\n  \n\n  values |> unlist() |> sum()\n\n}\n```\n:::\n\n\nNow we can apply these helper functions to all of the histories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <-\n  map(data, \\(x) predicted_next_history(x), .progress = 'Predicting Next History:')\n\nresults |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 187199\n\n[[2]]\n[1] 1072336\n\n[[3]]\n[1] 6716828\n\n[[4]]\n[1] 17445671\n\n[[5]]\n[1] 30121668\n\n[[6]]\n[1] 20883\n```\n\n\n:::\n:::\n\n\nOne we have all of the predicted next hsitories, we can take the sum to get the answer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults |> unlist() |> sum()\n```\n:::\n\n\n<!-- - 1772145754 [correct] -->\n\n# Part 2\n\nPart 2 of the puzzle is fairly simple, instead of the next value in the history we need to identify the previous value of the history. We simply modify the code to the `predicted_next_history` function to identify the reverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredicted_prev_history <- \\(history) {\n\n  all_zeroes <- FALSE\n  i <- 0\n  temp <- history\n  prev <- NULL\n  \n  while (all_zeroes == FALSE) {\n    new <- paste0('c', i + 1)\n    prev <- paste0('c', i)\n    \n    temp <- generate_new_columns(temp, new, prev)\n    new_column <- temp |> pull(!!new) |> na.omit()\n    all_zeroes <- all(new_column == 0)\n    \n    i <- i + 1\n    \n  }\n  \n  values <- map(temp, \\(x) {\n    vals <- x |> na.omit()\n    \n    return(vals[1])\n    \n  })\n  \n  \n  values <- values |>\n    unlist()\n  \n  values <- values[1:length(values) - 1]\n  \n  values <- rev(values)\n  \n  current_value <- 0\n  values <- map(values, \\(x) {\n    current_value <<- x - current_value\n    \n    \n  }) |> unlist()\n  \n  values[length(values)] |> unname()\n  \n}\n\nresults <-\n  map(data, \\(x) predicted_prev_history(x), .progress = 'Predicting Prev History:')\n\nresults |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 12\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 3\n\n[[4]]\n[1] 10\n\n[[5]]\n[1] 8\n\n[[6]]\n[1] 5\n```\n\n\n:::\n:::\n\n\nWith the results, we can take the sum to get the answer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresults |> unlist() |> sum()\n```\n:::\n\n\n<!-- - 867(correct) -->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}