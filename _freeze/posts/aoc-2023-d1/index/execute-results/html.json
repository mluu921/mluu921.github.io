{
  "hash": "9544263e94877cef12b6578a8e06a21f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advent of Code 2023, Day 1\"\ndate: '12/2/2023'\nwarning: false\nmessage: false\ncategories:\n  - advent of code\neditor_options: \n  chunk_output_type: console\nimage: \"https://miro.medium.com/max/1400/1*8NspdbQcI6w6tjZQ7kjS-A.png\"\n---\n\n\n![](https://miro.medium.com/v2/resize:fit:4800/format:webp/1*8NspdbQcI6w6tjZQ7kjS-A.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\n```\n:::\n\n\nIt's the season for [Advent of Code](https://adventofcode.com/) 2023. Advent of code is an 'advent calendar' of small programming puzzles that begins on 12/1 of every year and last until Christmas 12/25. The following is my solution of Day 1, Part 1 and Part 2 of the 2023 puzzle solved using R.\n\nWe begin by loading the puzzle input.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read_lines(\n  here('posts', 'aoc-2023-d1', 'puzzle-input.txt')\n)\n\ndata <- as_tibble(data)\n```\n:::\n\n\n# Part 1\n\nThe first part of the puzzle is fairly straight forward. We begin by using the `str_remove_all` function from the `stringr` package to remove all of the characters (and leave only the numeric) from the value column. Next we use `str_extract` to extract the first and last digit using regex, and `paste0` to paste the numbers together to get the 'calibration' value. Finally we sum the cal column to get the solution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- data |> \n  mutate(\n    digits = str_remove_all(value, '[:alpha:]'),\n    first = str_extract(digits, '^[:digit:]'),\n    last = str_extract(digits, '[:digit:]$'),\n    cal = as.numeric(paste0(first, last))\n  ) \n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000 × 5\n   value                                 digits first last    cal\n   <chr>                                 <chr>  <chr> <chr> <dbl>\n 1 9vxfg                                 9      9     9        99\n 2 19qdlpmdrxone7sevennine               197    1     7        17\n 3 1dzntwofour9nineffck                  19     1     9        19\n 4 7bx8hpldgzqjheight                    78     7     8        78\n 5 joneseven2sseven64chvczzn             264    2     4        24\n 6 seven82683                            82683  8     3        83\n 7 7onefour1eighttwo5three               715    7     5        75\n 8 8lmsk871eight7                        88717  8     7        87\n 9 ninefivefive2nine5ntvscdfdsmvqgcbxxxt 25     2     5        25\n10 onepx6hbgdssfivexs                    6      6     6        66\n# ℹ 990 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres |> \n  summarise(results = sum(cal))\n```\n:::\n\n\n\n# Part 2\n\nThe second part of the puzzle was extremely tricky. There are a number of special cases where the words are overlapping. My messy solution was to 'fix' those overlapping words such as 'twone' to 'twoone', using the `str_replace_all` function, then using additional `str_replace_all` to convert the words to numeric. Finally we would use a similar solution as above in extracting the first and last digit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_char_to_numeric <- \\(x) {\n  \n  # special cases with overlapping characters\n  x <- str_replace_all(x, 'twone', 'twoone') |> \n    str_replace_all('oneight', 'oneeight') |> \n    str_replace_all('sevenine', 'sevennine') |> \n    str_replace_all('threeight', 'threeeight') |> \n    str_replace_all('fiveight', 'fiveeight') |> \n    str_replace_all('eightwo', 'eighttwo') |> \n    str_replace_all('eighthree', 'eightthree') |> \n    str_replace_all('nineight', 'nineeight')\n  \n  x <- str_replace_all(x, 'one', '1') |>\n    str_replace_all('two', '2') |>\n    str_replace_all('three', '3') |>\n    str_replace_all('four', '4') |>\n    str_replace_all('five', '5') |>\n    str_replace_all('six', '6') |>\n    str_replace_all('seven', '7') |>\n    str_replace_all('eight', '8') |>\n    str_replace_all('nine', '9')\n  \n}\n\nres <- data |> \n  mutate(\n    value2 = convert_char_to_numeric(value),\n    digits = str_remove_all(value2, '[:alpha:]'),\n    first = str_extract(digits, '^[:digit:]'),\n    last = str_extract(digits, '[:digit:]$'),\n    cal = as.numeric(paste0(first, last))\n  ) \n\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,000 × 6\n   value                                 value2         digits first last    cal\n   <chr>                                 <chr>          <chr>  <chr> <chr> <dbl>\n 1 9vxfg                                 9vxfg          9      9     9        99\n 2 19qdlpmdrxone7sevennine               19qdlpmdrx1779 191779 1     9        19\n 3 1dzntwofour9nineffck                  1dzn2499ffck   12499  1     9        19\n 4 7bx8hpldgzqjheight                    7bx8hpldgzqjh8 788    7     8        78\n 5 joneseven2sseven64chvczzn             j172s764chvcz… 172764 1     4        14\n 6 seven82683                            782683         782683 7     3        73\n 7 7onefour1eighttwo5three               71418253       71418… 7     3        73\n 8 8lmsk871eight7                        8lmsk87187     887187 8     7        87\n 9 ninefivefive2nine5ntvscdfdsmvqgcbxxxt 955295ntvscdf… 955295 9     5        95\n10 onepx6hbgdssfivexs                    1px6hbgdss5xs  165    1     5        15\n# ℹ 990 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres |> summarise(results = sum(cal))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}