{
  "hash": "93d7213c4eb36856f1ddeb7714c7a0ac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Environments\"\ndate: '2-27-2024'\nimage: 'https://images.unsplash.com/photo-1702421098381-f6f180cf13bd?q=80&w=3870&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'\ndraft: false\ntoc: true\neditor_options: \n  chunk_output_type: console\ncategories:\n  - programming\n---\n\n\nThe following blog post hopes to demystify the concept of environments in R.\n\n\n::: {.cell}\n\n:::\n\n\n# Example 1\n\nLet's start off by looking at a very simple example\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1\nb <- 2\nc <- 3\n\na + b + c\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nIn this code chunk we are defining the objects `a`, `b`, and `c`, and then adding them together. The important take away of this, is that the objects `a`, `b`, and `c` are all defined in the global environment.\n\nWe can check the environment by using the following function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::current_env()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\nThe `current_env` function returns the current environment. In this case, it returns the global environment. The global environment is the top level environment in R. It is the environment where all objects are defined by default. However, we can also define objects within other environments. For example, whenever we are working with a function, the objects defined within the function are defined within the function's environment.\n\nAlthough we can call the current environment with `current_env()`, we can also capture the environment into an object using the following example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv <- rlang::current_env()\n```\n:::\n\n\nNow that we have the environment captured, we can use the `env` object to access objects that were defined within the environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"env\"                 \"a\"                   \".QuartoInlineRender\"\n[4] \"b\"                   \"c\"                   \".main\"              \n```\n\n\n:::\n\n```{.r .cell-code}\nc(env$a, env$b, env$c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n:::\n\n\n# Example 2\n\nNow let's try this again, except we're going to define the objects within a local environment. I'm going to redefine the objects `a`, `b`, and `c` within a local environment, and then add them together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocal({\n  a <- 4\n  b <- 5\n  c <- 6\n  \n  env <- rlang::current_env()\n  \n  values <- c(a, b, c)\n  \n  results <- a + b + c\n  \n  tibble::lst(env,\n              values,\n              results)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$env\n<environment: 0x0000027c4a61f4d8>\n\n$values\n[1] 4 5 6\n\n$results\n[1] 15\n```\n\n\n:::\n:::\n\n\nWe can see here the name of the local environment, as well as the results of adding the objects `a`, `b`, and `c` together, using the objects defined within the local environment.\n\n# Example 3\n\nWhat if we are working within a local environment that already has the objects `a`, `b`, and `c` defined? However, we would like to use the objects `a`, `b`, and `c` that are defined in the global environment.\n\nLet's take a look at the following example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocal({\n  a <- 4\n  b <- 5\n  c <- 6\n  \n  env <- current_env()\n  \n  values <- c(a, b, c)\n  \n  r_expression <- rlang::expr(a + b + c)\n  \n  results <- eval_tidy(r_expression, env = global_env())\n  \n  tibble::lst(\n    env,\n    values,\n    results\n  )\n  \n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$env\n<environment: 0x0000027c4a8623b8>\n\n$values\n[1] 4 5 6\n\n$results\n[1] 6\n```\n\n\n:::\n:::\n\n\nIn this example, we are defining the objects `a`, `b`, and `c` within a local environment. We then use the `expr` function to capture the expression `a + b + c`. We then use the `eval_tidy` function to evaluate the expression `a + b + c` within the global environment. This allows us to use the objects `a`, `b`, and `c` that are defined in the global environment, within the local environment.\n\n# Example 4\n\nWhat if we want to use the objects `a` from the global environment, and `b` and `c` from the local environment? We can actually simplify the code by explicitly calling the object `a` from the global environment `global`, and then adding the objects `b` and `c`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlocal({\n  a <- 4\n  b <- 5\n  c <- 6\n  \n  env <- rlang::current_env()\n  global <- rlang::global_env()\n  \n  results <- global$a + b + c\n  \n  values <- c(global$a, b, c)\n  \n  tibble::lst(\n    env,\n    values,\n    results\n  )\n  \n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$env\n<environment: 0x0000027c4aac9f50>\n\n$values\n[1] 1 5 6\n\n$results\n[1] 12\n```\n\n\n:::\n:::\n\n\nIn this example, we are defining the objects `a`, `b`, and `c` within a local environment. We then use the `global_env` function to capture the global environment into an object called `global`. We then add the objects `b` and `c` to the object `a` that is defined in the global environment.\n\n# Example 5\n\nNow that we have some of the basic fundamentals down, let's get a little more complex. \n\nA very typical workflow in R while creating new columns in a dataframe is to use the `mutate` function from dplyr. We would normally pipe the dataframe into `mutate` and define the new column. The output of `mutate` is a dataframe itself, in which we reassign the original dataframe with the new dataframe with the new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- tibble(i = 1:26)\n\ndata <- data |> \n  mutate(\n    column_a = rnorm(26)\n  )\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 26 × 2\n       i column_a\n   <int>    <dbl>\n 1     1   0.455 \n 2     2   0.226 \n 3     3   0.0299\n 4     4   0.0565\n 5     5   1.27  \n 6     6   0.962 \n 7     7   1.77  \n 8     8   0.313 \n 9     9   1.41  \n10    10   0.469 \n# ℹ 16 more rows\n```\n\n\n:::\n:::\n\n\nWhat if we wanted to create 26 new columns, each with a different name and different values. Instead of manually using mutate for all 26 columns, let's use a functional programming approach to accomplish this goal.\n\nIn this example i'm going to use `purrr::walk` to iterate over the list of column names. `purrr::walk` does not return anything, instead we invoke `purrr::walk` for it's side effects. What's important here is that while invoking `purrr::walk` we are operating within a function, and the function has it's own environment. What we're going to do is to define the global environment as `env` and call the object data from the global environment. We will then iterate over, create the new column within the global `data` object and then reassign the global `data` object with the new dataframe with the new column. When we call the `data` object from the global environment, we have the new dataframe with the newly created objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- tibble(i = 1:26)\n\ncolumn_names <- paste0(\"column_\", letters[1:26])\n\nwalk(column_names, \\(x) {\n  \n  env <- global_env()\n  \n  env$data <- env$data |> \n    mutate(\n      !!x := rnorm(26)\n    )\n  \n})\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 26 × 27\n       i column_a column_b column_c column_d column_e column_f column_g column_h\n   <int>    <dbl>    <dbl>    <dbl>    <dbl>    <dbl>    <dbl>    <dbl>    <dbl>\n 1     1   2.54    -1.50     0.945    1.69    -0.0870  -1.07      0.533  -1.73  \n 2     2  -0.566   -2.38    -0.951   -0.117    0.494   -0.172     0.106  -0.483 \n 3     3  -0.489   -0.0235  -0.396    0.0982  -0.0762   0.653     0.684  -0.157 \n 4     4  -1.05     1.92     1.71    -0.285    0.897   -2.10      0.234   0.141 \n 5     5  -1.27    -1.07    -0.0825   1.52    -0.850    0.881    -0.632  -0.0621\n 6     6  -0.803    0.422   -1.36    -2.60     0.132   -1.68      0.957  -0.567 \n 7     7  -0.128   -0.680    0.297   -0.928   -0.722    0.856    -1.43    0.915 \n 8     8  -0.0326   1.64     0.933    0.329    0.452    0.553    -0.380   0.608 \n 9     9   0.117    1.27     0.240    1.50     0.658   -0.0955   -0.397  -1.31  \n10    10   1.02    -1.12    -1.27     1.45    -0.532    0.321    -0.991  -1.53  \n# ℹ 16 more rows\n# ℹ 18 more variables: column_i <dbl>, column_j <dbl>, column_k <dbl>,\n#   column_l <dbl>, column_m <dbl>, column_n <dbl>, column_o <dbl>,\n#   column_p <dbl>, column_q <dbl>, column_r <dbl>, column_s <dbl>,\n#   column_t <dbl>, column_u <dbl>, column_v <dbl>, column_w <dbl>,\n#   column_x <dbl>, column_y <dbl>, column_z <dbl>\n```\n\n\n:::\n:::\n\n\n# Conclusion\n\nIn summary, it's extremely powerful to be able to specifically call objects from different environments. This allows us to use objects that are defined in different environments, within the same expression. Hopefully, this helps with demystyfing the concepts of environments within R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}